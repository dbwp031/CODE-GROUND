# Java-transaction
트랜잭션 관리를 위한 java 코드 예제
## 트랜잭션 격리 수준에 따라 발생 가능한 부정합 문제
| Isolation Level  | Dirty Read | Non-Repeatable Read | Phantom Read      |
| ---------------- | ---------- | ------------------- | ----------------- |
| READ UNCOMMITTED | 발생         | 발생                  | 발생                |
| READ COMMITTED   | 없음         | 발생                  | 발생                |
| REPEATABLE READ  | 없음         | 없음                  | 발생  |
| SERIALIZABLE     | 없음         | 없음                  | 없음                |

## 부정합 문제 발생 시나리오
### 1. Dirty Read


# Lock
## 낙관적 락 vs 배타적 락 비교

| 구분               | 낙관적 락 (Optimistic Lock)                                                     | 배타적 락 (Pessimistic Lock)                                                     |
|--------------------|--------------------------------------------------------------------------------|---------------------------------------------------------------------------------|
| **특징**           | - 버전 정보를 기반으로 동시성 충돌 감지<br>- 별도의 데이터베이스 락 없이 처리<br>- 충돌 시 예외 발생 후 재시도 필요 | - 데이터베이스 레벨에서 락을 획득해 동시 접근 제한<br>- 충돌 발생 전 예방<br>- 직접 락 관리 필요  |
| **장점**           | - 낮은 오버헤드<br>- 높은 동시성 처리 가능<br>- 데드락 위험 감소               | - 강력한 데이터 정합성 보장<br>- 충돌 방지에 효과적<br>- 재시도 로직 불필요          |
| **단점**           | - 동시 수정 충돌 발생 시 재시도 로직 구현 필요<br>- 충돌 빈도가 높으면 성능 저하 우려    | - 락 획득으로 인한 대기 시간 발생<br>- 시스템 전체 동시성 감소 가능<br>- 데드락 위험 존재       |
| **대표 사용 사례** | - 읽기 작업이 많은 웹 애플리케이션<br>- 충돌 발생 빈도가 낮은 경우             | - 티케팅, 은행 거래, 자원 예약 등 높은 동시 수정이 예상되는 환경                         |
